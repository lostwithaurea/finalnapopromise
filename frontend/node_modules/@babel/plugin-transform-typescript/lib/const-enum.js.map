<<<<<<< HEAD
{"version":3,"names":["transpileConstEnum","path","t","name","node","id","parentIsExport","parentPath","isExportNamedDeclaration","isExported","isProgram","parent","body","some","stmt","exportKind","source","specifiers","spec","isExportSpecifier","local","entries","translateEnumValues","obj","objectExpression","map","value","objectProperty","isValidIdentifier","identifier","stringLiteral","scope","hasOwnBinding","replaceWith","expressionStatement","callExpression","memberExpression","variableDeclaration","variableDeclarator","registerDeclaration","entriesMap","Map","traverse","Scope","skip","MemberExpression","isIdentifier","object","key","computed","isStringLiteral","property","has","cloneNode","get","remove"],"sources":["../src/const-enum.ts"],"sourcesContent":["import type * as t from \"@babel/types\";\nimport type { NodePath } from \"@babel/traverse\";\n\nimport { translateEnumValues } from \"./enum\";\n\nexport type NodePathConstEnum = NodePath<t.TSEnumDeclaration & { const: true }>;\nexport default function transpileConstEnum(\n  path: NodePathConstEnum,\n  t: typeof import(\"@babel/types\"),\n) {\n  const { name } = path.node.id;\n\n  const parentIsExport = path.parentPath.isExportNamedDeclaration();\n  let isExported = parentIsExport;\n  if (!isExported && t.isProgram(path.parent)) {\n    isExported = path.parent.body.some(\n      stmt =>\n        t.isExportNamedDeclaration(stmt) &&\n        stmt.exportKind !== \"type\" &&\n        !stmt.source &&\n        stmt.specifiers.some(\n          spec =>\n            t.isExportSpecifier(spec) &&\n            spec.exportKind !== \"type\" &&\n            spec.local.name === name,\n        ),\n    );\n  }\n\n  const entries = translateEnumValues(path, t);\n\n  if (isExported) {\n    const obj = t.objectExpression(\n      entries.map(([name, value]) =>\n        t.objectProperty(\n          t.isValidIdentifier(name)\n            ? t.identifier(name)\n            : t.stringLiteral(name),\n          value,\n        ),\n      ),\n    );\n\n    if (path.scope.hasOwnBinding(name)) {\n      (parentIsExport ? path.parentPath : path).replaceWith(\n        t.expressionStatement(\n          t.callExpression(\n            t.memberExpression(t.identifier(\"Object\"), t.identifier(\"assign\")),\n            [path.node.id, obj],\n          ),\n        ),\n      );\n    } else {\n      path.replaceWith(\n        t.variableDeclaration(\"var\", [t.variableDeclarator(path.node.id, obj)]),\n      );\n      path.scope.registerDeclaration(path);\n    }\n\n    return;\n  }\n\n  const entriesMap = new Map(entries);\n\n  // TODO: After fixing https://github.com/babel/babel/pull/11065, we can\n  // use path.scope.getBinding(name).referencePaths rather than doing\n  // a full traversal.\n  path.scope.path.traverse({\n    Scope(path) {\n      if (path.scope.hasOwnBinding(name)) path.skip();\n    },\n    MemberExpression(path) {\n      if (!t.isIdentifier(path.node.object, { name })) return;\n\n      let key: string;\n      if (path.node.computed) {\n        if (t.isStringLiteral(path.node.property)) {\n          key = path.node.property.value;\n        } else {\n          return;\n        }\n      } else if (t.isIdentifier(path.node.property)) {\n        key = path.node.property.name;\n      } else {\n        return;\n      }\n      if (!entriesMap.has(key)) return;\n\n      path.replaceWith(t.cloneNode(entriesMap.get(key)));\n    },\n  });\n\n  path.remove();\n}\n"],"mappings":"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"}
=======
{"version":3,"names":["transpileConstEnum","path","t","name","node","id","parentIsExport","parentPath","isExportNamedDeclaration","isExported","isProgram","parent","body","some","stmt","exportKind","source","specifiers","spec","isExportSpecifier","local","entries","translateEnumValues","obj","objectExpression","map","value","objectProperty","isValidIdentifier","identifier","stringLiteral","scope","hasOwnBinding","replaceWith","expressionStatement","callExpression","memberExpression","variableDeclaration","variableDeclarator","registerDeclaration","entriesMap","Map","traverse","Scope","skip","MemberExpression","isIdentifier","object","key","computed","isStringLiteral","property","has","cloneNode","get","remove"],"sources":["../src/const-enum.ts"],"sourcesContent":["import type * as t from \"@babel/types\";\nimport type { NodePath } from \"@babel/traverse\";\n\nimport { translateEnumValues } from \"./enum\";\n\nexport type NodePathConstEnum = NodePath<t.TSEnumDeclaration & { const: true }>;\nexport default function transpileConstEnum(\n  path: NodePathConstEnum,\n  t: typeof import(\"@babel/types\"),\n) {\n  const { name } = path.node.id;\n\n  const parentIsExport = path.parentPath.isExportNamedDeclaration();\n  let isExported = parentIsExport;\n  if (!isExported && t.isProgram(path.parent)) {\n    isExported = path.parent.body.some(\n      stmt =>\n        t.isExportNamedDeclaration(stmt) &&\n        stmt.exportKind !== \"type\" &&\n        !stmt.source &&\n        stmt.specifiers.some(\n          spec =>\n            t.isExportSpecifier(spec) &&\n            spec.exportKind !== \"type\" &&\n            spec.local.name === name,\n        ),\n    );\n  }\n\n  const entries = translateEnumValues(path, t);\n\n  if (isExported) {\n    const obj = t.objectExpression(\n      entries.map(([name, value]) =>\n        t.objectProperty(\n          t.isValidIdentifier(name)\n            ? t.identifier(name)\n            : t.stringLiteral(name),\n          value,\n        ),\n      ),\n    );\n\n    if (path.scope.hasOwnBinding(name)) {\n      (parentIsExport ? path.parentPath : path).replaceWith(\n        t.expressionStatement(\n          t.callExpression(\n            t.memberExpression(t.identifier(\"Object\"), t.identifier(\"assign\")),\n            [path.node.id, obj],\n          ),\n        ),\n      );\n    } else {\n      path.replaceWith(\n        t.variableDeclaration(\"var\", [t.variableDeclarator(path.node.id, obj)]),\n      );\n      path.scope.registerDeclaration(path);\n    }\n\n    return;\n  }\n\n  const entriesMap = new Map(entries);\n\n  // TODO: After fixing https://github.com/babel/babel/pull/11065, we can\n  // use path.scope.getBinding(name).referencePaths rather than doing\n  // a full traversal.\n  path.scope.path.traverse({\n    Scope(path) {\n      if (path.scope.hasOwnBinding(name)) path.skip();\n    },\n    MemberExpression(path) {\n      if (!t.isIdentifier(path.node.object, { name })) return;\n\n      let key: string;\n      if (path.node.computed) {\n        if (t.isStringLiteral(path.node.property)) {\n          key = path.node.property.value;\n        } else {\n          return;\n        }\n      } else if (t.isIdentifier(path.node.property)) {\n        key = path.node.property.name;\n      } else {\n        return;\n      }\n      if (!entriesMap.has(key)) return;\n\n      path.replaceWith(t.cloneNode(entriesMap.get(key)));\n    },\n  });\n\n  path.remove();\n}\n"],"mappings":"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"}
>>>>>>> 96d1909df (deploy build)
